#!/bin/sh
# Ubiquiti appliance system tools                -*- shell-script -*-
# Copyright (c) 2012-2015 Ubiquiti Networks, Inc. http://www.ubnt.com
# vim: ft=sh

PATH=/bin:/sbin:/usr/bin:/usr/sbin
REBOOT_REASON_PATH="/persistent/report/reboot_reason"
PPID_CMD_PATH="/persistent/report/ppid_cmd"
HOOK_HOSTNAME_CHANGE_PATH="/usr/lib/ubnt/hooks/system/hostname-change-bottom/"

usage() {
	echo "Ubiquiti system tools, v1.0"
	echo "Usage: $0 <command> [<arguments>]"
	echo "  supported commands:"
	echo "     timezone <newtimezone>"
	echo "     hostname <newhostname>"
	echo "     network  <networkinterfacefile>"
	echo "     network-speed  <networkinterface> <speedmbps>"
	echo "     network-speed-init"
	echo "     fwupdate <updatefile>"
	echo "     fwupdatestatus"
	echo "     resetbutton <true|false>"
	echo "     sshd <true|false>"
	echo "     sshd-authkeys [<new authkey file>]"
	echo "     sshd-passwdauth [<true|false>]"
	echo "     sshd-port [<port number>]"
	echo "     support [<outputfile>]"
	echo "     pwcheck"
	echo "     chpasswd"
	echo "     adminname <newname>"
	echo "     adminemail <newemail>"
	echo "     reboot"
	echo "     poweroff"
	echo "     reset2defaults"
	echo "     cleanup"
	echo "     synctime"
	echo "     storage <action> <arg>"
	echo "     cputemp"
	echo "     sysusermerge <ro-mount>"
	echo "     cpuload"
	echo "     sshpasswd <action> <arg>"
	echo "     sysuser_remap <ro-mount>"

	exit 1
}

# prints error message and exits the process with the given error code
# args: <exit code> <message>
err() {
	local rc
	rc=$1
	shift
	msg=$*
	printf "ERROR: ${msg}\n"
	exit ${rc}
}

internal_cleanup() {
	if [ -n "${CLEANUP_FILES}" ]; then
		rm -f ${CLEANUP_FILES}
	fi
	for d in ${CLEANUP_DIRS}; do
		[ -d "$d" ] && rm -rf $d;
	done
	if command -v dotlockfile >/dev/null 2>&1; then
		for f in ${CLEANUP_LOCKFILES}; do
			dotlockfile -u $f;
		done
	fi
}

cleanup_init() {
	CLEANUP_FILES=
	CLEANUP_LOCKFILES=
	CLEANUP_DIRS=
}

# args: <directory>
cleanup_add_dir() {
	CLEANUP_DIRS="${CLEANUP_DIRS} $1"
}

# args: <file path>
cleanup_add_file() {
	CLEANUP_FILES="${CLEANUP_FILES} $1"
}

# args: <file path>
cleanup_add_lockfile() {
	CLEANUP_LOCKFILES="${CLEANUP_LOCKFILES} $1"
}

copy_file() {
	if [ -f "$1" ]; then
		cp -f $1 $2
	else
		return 1
	fi
}

# moves the given source file to destination via "atomic" rename fashion
# args: <source file> <destination>
move_file() {
	local ddir
	if [ -d "$2" ]; then
		ddir="$2"
	else
		ddir=$(dirname "$2")
	fi
	local tfile=$(mktemp -p "${ddir}" "${1}.XXXXXX")
	cleanup_add_file "${tfile}"
	mv -f "$1" "${tfile}"
	mv -f "${tfile}" "$2"
}

change_admin() {
	local LOCKFILE field
	local newadmin newadminuid
	local oldadmin oldadminuid
	local invalidformat rc
	local usermaptmpf shadowtmpf passwdtmpf
	LOCKFILE="/run/lock/chadmin"
	field=$1
	newadmin=$2

	cleanup_init

	if [ "${field}" != "name" -a "${field}" != "email" ]; then
		return 0
	fi

	if [ ${#newadmin} -gt 32 ]; then
		err 1 "${newadmin} is too long (max len:32) !"
	fi

	invalidformat=1
	if [ "${field}" != "email" ]; then
		expr match "${newadmin}" "^[a-zA-Z][-a-zA-Z0-9_]*$" >/dev/null 2>&1
		invalidformat=$?
	else
		expr match "${newadmin}" "^[a-zA-Z][-a-zA-Z0-9_@.+%]*[-a-zA-Z0-9_]$" >/dev/null 2>&1
		invalidformat=$?
	fi

	if [ "${newadmin}" = "" -o "${newadmin}" = "root" -o ${invalidformat} -ne 0 ]; then
		err 1 "invalid format: ${newadmin} !"
	fi

	dotlockfile -l -p -r 1 ${LOCKFILE}
	rc=$?
	if [ $rc -ne 0 ]; then
		err 1 "cannot aquire lock file (${LOCKFILE}) !"
	fi
	cleanup_add_lockfile ${LOCKFILE}

	if [ "${field}" != "email" ]; then
		oldadmin=$(awk -F: '/root/{if ($1 != "root") print $1}' /etc/security/usermap.conf | sed -n '1p')
	else
		oldadmin=$(awk -F: '/root/{if ($1 != "root") print $1}' /etc/security/usermap.conf | sed -n '2p')
	fi

	if [ "${oldadmin}" = "" ]; then
		return 0
	fi

	if [ "${newadmin}" = "${oldadmin}" ]; then
		err 1 "new admin (${newadmin}) is the same as old admin (${oldadmin}) !"
	fi

	oldadminuid=$(id -u ${oldadmin} 2>/dev/null)
	if [ "${oldadminuid}" != "" ]; then
		if [ ${oldadminuid} -gt 0 ]; then
			err 1 "current admin (${oldadmin}) exists with non-zero UID (${oldadminuid}) !"
		fi
	fi

	newadminuid=$(id -u ${newadmin} 2>/dev/null)
	if [ "${newadminuid}" != "" ]; then
		err 1 "new admin (${newadmin}) already exists with UID: ${newadminuid} !"
	fi

	usermaptmpf=`mktemp usermap.XXXXXXXX`
	cleanup_add_file "${usermaptmpf}"

	sed "s,^${oldadmin}:,${newadmin}:,g" /etc/security/usermap.conf > ${usermaptmpf}
	rc=$?
	if [ $rc -ne 0 ]; then
		err 1 "replace ${oldadmin} with ${newadmin} in /etc/security/usermap.conf failed!"
	fi

	if [ "${oldadminuid}" = "" ]; then
		# use useradd command to add newadmin if oldadmin doesn't exist in the system
		useradd -o -d /root -g 0 -u 0 -s /bin/bash ${newadmin}
		rc=$?
		if [ $rc -ne 0 ]; then
			err 1 "replace ${oldadmin} with ${newadmin} in /etc/shadow failed!"
		fi
	else
		# replace oldadmin with newadmin in /etc/shadow and /etc/shadow
		shadowtmpf=`mktemp shadow.XXXXXXXX`
		cleanup_add_file "${shadowtmpf}"

		sed "s,^${oldadmin}:,${newadmin}:,g" /etc/shadow > ${shadowtmpf}
		rc=$?
		if [ $rc -ne 0 ]; then
			err 1 "replace ${oldadmin} with ${newadmin} in /etc/shadow failed!"
		fi

		passwdtmpf=`mktemp passwd.XXXXXXXX`
		cleanup_add_file "${passwdtmpf}"

		sed "s,^${oldadmin}:,${newadmin}:,g" /etc/passwd > ${passwdtmpf}
		rc=$?
		if [ $rc -ne 0 ]; then
			err 1 "replace ${oldadmin} with ${newadmin} in /etc/passwd failed!"
		fi
		mv ${shadowtmpf} /etc/shadow && chmod 640 /etc/shadow
		mv ${passwdtmpf} /etc/passwd && chmod 644 /etc/passwd
	fi

	mv ${usermaptmpf} /etc/security/usermap.conf && chmod 644 /etc/security/usermap.conf

	dotlockfile -u ${LOCKFILE}
	return 0
}

change_timezone() {
	tzname=$1
	tzfile="/usr/share/zoneinfo/$1"
	if [ -f $tzfile ]; then
		if ! timedatectl set-timezone "${tzname}"; then
			rm -f /etc/localtime
			cp -f $tzfile /etc/localtime
			echo "$tzname" > /etc/timezone
		fi
	else
		err 1 "Timezone $tzname does not exist."
	fi
}

change_hostname() {
	echo "$1" > /etc/hostname
	echo "$1" > /proc/sys/kernel/hostname
	local HLINE="127.0.1.1	${1}"
	if grep -q 127.0.1.1 /etc/hosts 2>/dev/null; then
		sed -i "s/^127.0.1.1.*/${HLINE}/" /etc/hosts
	else
		echo "$HLINE" >> /etc/hosts
	fi

	if command -v run-parts >/dev/null 2>&1 && [ -d "$HOOK_HOSTNAME_CHANGE_PATH" ]; then
		run-parts "$HOOK_HOSTNAME_CHANGE_PATH" >/dev/null 2>&1
	fi
}

change_network_ifupdown() {
	if [ -f "$1" ]; then
		if diff -q $1 /etc/network/interfaces >/dev/null 2>&1; then
			echo "no changes, skipping update"
		else
			ifdown -a -X lo
			copy_file $1 /etc/network/interfaces
			ifup -a
		fi
	else
		err 2 "File not found: $1"
	fi
}

# args: <systemd service> <new service file>
change_network_systemd() {
	if [ ! -f "$2" ]; then
		err 2 "File not found: $2"
	fi

	if diff -q $2 /etc/systemd/network/$1 >/dev/null 2>&1; then
		echo "no changes, skipping update"
	else
		copy_file $2 /etc/systemd/network/$1
		chmod 0644 /etc/systemd/network/$1
		systemctl restart systemd-networkd
		systemctl restart systemd-networkd-fallbacker@${1%.network}
	fi
}

change_network() {
	# TODO: is /run/systemd/netif sufficient indicator?
	if [ -d /run/systemd/netif ]; then
		change_network_systemd $2.network $1
	else
		change_network_ifupdown $1
	fi
}

init_network_speed() {
	local CFGDIR=/etc/network-speed/
	[ -d ${CFGDIR} ] || return 0

	for iface_config in ${CFGDIR}*; do
		[ -f "$iface_config" ] || continue
		speed=$(cat ${iface_config})
		interface=${iface_config##*/}
		ethtool -s ${interface} autoneg off speed ${speed} 2>&1
	done
}

# args: <nic> <speed (mbps) | auto-neg>
change_network_speed() {
	local CFGDIR=/etc/network-speed/
	local CFGFILE=${CFGDIR}$1

	if [ "$2" = "auto-nego" ]; then
		# Don't update config if ethtool fails
		ethtool -s $1 autoneg on 2>&1 || return 1

		[ -f "${CFGFILE}" ] && rm -f ${CFGFILE}
	else
		# Don't update config if ethtool fails
		ethtool -s $1 autoneg off speed $2 2>&1 || return 1

		[ -d "${CFGDIR}" ] || mkdir -p ${CFGDIR}
		echo $2 > ${CFGFILE}
	fi
}

# args: <nic>
show_network_speed() {
	local speed=$(ethtool $1 2>/dev/null | grep Speed | awk '{print $2}' | cut -dM -f1)
	local autoneg=$(ethtool $1 2>/dev/null | grep Auto-negotiation | awk '{print $2}')
	[ "$speed" -eq "$speed" ] 2>/dev/null || speed=0
	echo "{\"speed\":${speed},\"auto-nego\":\"${autoneg}\"}"
}

do_resetbutton() {
	local CFGFILE=/etc/default/infctld
	local VAL=enabled
	[ -f "${CFGFILE}" ] || (touch "${CFGFILE}"; chmod go+r "${CFGFILE}")
	. "${CFGFILE}"
	# cleanup leading whitespace
	INFCTLD_ARGS=${INFCTLD_ARGS#"${INFCTLD_ARGS%%[![:space:]]*}"}
	# -n indicates that reset button is disabled
	[ "${INFCTLD_ARGS#*-n}" != "${INFCTLD_ARGS}" ] && VAL=disabled

	if [ $# -eq 0 ]; then
		echo $VAL
	else
		local NEWVAL=enabled
		[ "$1" = "false" -o "$1" = "no" -o "$1" = "disable" ] && NEWVAL=disabled

		[ "${NEWVAL}" = "${VAL}" ] && return

		tmpfile=$(mktemp infctld.XXXXXXXX)

		if [ "$NEWVAL" = "disabled" ]; then
			sed '/INFCTLD_ARGS/d' "${CFGFILE}" > ${tmpfile}
			printf "INFCTLD_ARGS=\"${INFCTLD_ARGS} -n\"" >> ${tmpfile}
		else
			sed '/INFCTLD_ARGS/ s/\-n//g' "${CFGFILE}" > ${tmpfile}
		fi
		mv ${tmpfile} ${CFGFILE}
		service infctld restart
	fi
}

do_sshd() {
	local VAL=enabled
	systemctl -q is-enabled ssh || VAL=disabled
	if [ $# -eq 0 ]; then
		echo $VAL
	else
		local NEWVAL=enabled
		[ "$1" = "false" -o "$1" = "no" -o "$1" = "disable" ] && NEWVAL=disabled
		[ "${NEWVAL}" = "${VAL}" ] && return
		if [ "$NEWVAL" = "disabled" ]; then
			systemctl disable ssh
			systemctl --no-block stop ssh || true
		else
			systemctl enable ssh
			systemctl --no-block restart ssh
		fi
	fi
}

do_ssh() {
	do_sshd $@
}

SSHD_CONFIGDIR=${SSHD_CONFIGDIR:-/etc/ssh}
SSHD_CONFIG="${SSHD_CONFIGDIR}/sshd_config"

# args: [<port>]
do_sshdport() {
	local VAL
	VAL=$(sed -n '/^[ \t]*#/d; s/^[ \t]*Port[ \t]*\([0-9]*\)[ \t]*/\1/p' "${SSHD_CONFIG}")
	[ -n "${VAL}" ] || VAL=22

	if [ $# -eq 0 ]; then
		echo $VAL
	else
		[ "$1" != "${VAL}" ] || return
		[ "$1" -gt 0 -a "$1" -lt 65536 ] 2>/dev/null || err 1 "Invalid port number: $1"

		# TODO: more explicit locks

		local sshdcfg=$(mktemp sshd_config.XXXXXXXX)
		cleanup_init
		cleanup_add_file ${sshdcfg}

		sed '/^[ \t]*Port[ \t]/d' "${SSHD_CONFIG}" > "${sshdcfg}"
		printf "Port $1\n" >> "${sshdcfg}"

		if sshd -t -f "${sshdcfg}"; then
			move_file "${sshdcfg}" "${SSHD_CONFIG}"
			if systemctl -q is-enabled ssh; then
				systemctl --no-block restart ssh
			fi
		fi
	fi
}

# args: [<enable|disable>]
do_sshdpasswdauth() {
	local VAL
	VAL=$(sed -n '/^[ \t]*#/d; s/^[ \t]*PasswordAuthentication[ \t]*\([^\s]*\)[ \t]*/\1/p' "${SSHD_CONFIG}")
	[ -n "${VAL}" ] || VAL=yes

	if [ $# -eq 0 ]; then
		if [ "$VAL" = "yes" ]; then
			echo "enabled"
		else
			echo "disabled"
		fi
	else
		local NEWVAL=yes
		[ "$1" = "false" -o "$1" = "no" -o "$1" = "disable" ] && NEWVAL=no
		[ "${NEWVAL}" = "${VAL}" ] && return

		# TODO: more explicit locks
		local sshdcfg=$(mktemp sshd_config.XXXXXXXX)
		cleanup_init
		cleanup_add_file ${sshdcfg}

		sed '/^[ \t]*PasswordAuthentication[ \t]/d' "${SSHD_CONFIG}" > ${sshdcfg}
		printf "PasswordAuthentication ${NEWVAL}\n" >> ${sshdcfg}

		if sshd -t -f ${sshdcfg}; then
			move_file ${sshdcfg} "${SSHD_CONFIG}"
			if systemctl -q is-enabled ssh; then
				systemctl --no-block restart ssh
			fi
		fi
	fi
}

SSHD_AUTHKEYDIR=${SSHD_AUTHKEYDIR:-/root/.ssh}
SSHD_AUTHKEYS="${SSHD_AUTHKEYDIR}/authorized_keys"

# args: [<new file>]
do_sshdauthkeys() {
	umask 022
	[ -e "${SSHD_AUTHKEYS}" ] || (mkdir -p "${SSHD_AUTHKEYDIR}" && touch "${SSHD_AUTHKEYS}")
	if [ $# -eq 0 ]; then
		cat "${SSHD_AUTHKEYS}"
	else
		[ -f "$1" ] || err 1 "not a regular file: $1"
		move_file "$1" "${SSHD_AUTHKEYS}"
	fi
}

sed_pii_filter() {
	local STR=$1
	local DELIMS="][' \",|:(){}="
	echo "s/$STR\\\([$DELIMS]*\\\)[^$DELIMS]\+\\\([$DELIMS]*\\\)/$STR\\\1<FILTERED>\\\2/gI"
}

# args: [<path to filter>]
filter_pii_data() {
	find $1 -type f -print0 | xargs -0 sed -i \
		-e "$(sed_pii_filter password)" -e "$(sed_pii_filter psk)" \
		-e "$(sed_pii_filter key)" -e "$(sed_pii_filter token)" \
		-e "$(sed_pii_filter secret)" -e "$(sed_pii_filter passphrase)" \
		-e "$(sed_pii_filter wep)" -e "$(sed_pii_filter wpa)" \
		-e "$(sed_pii_filter signature)" -e "$(sed_pii_filter community)" \
		-e "$(sed_pii_filter anonymous_device_id)" -e "$(sed_pii_filter anonid)" \
		-e "$(sed_pii_filter anon_id)" -e "$(sed_pii_filter anonymousDeviceId)"
}

# args: [<output file>]
do_support() {
	local DATADIR=${DATADIR:-/var/tmp/}
	# local SUBPATH=${1:-support}
	# local FULLPATH=${DATADIR}/${SUBPATH}
	local FULLPATH=${1:-${DATADIR}/support}
	mkdir -p "$FULLPATH" || return 1
	(
		[ -d /usr/etc/supportinfo.d ] && run-parts -a "${FULLPATH}" /usr/etc/supportinfo.d >/dev/null 2>&1 || true
		[ -d /etc/supportinfo.d ] && run-parts -a "${FULLPATH}" /etc/supportinfo.d >/dev/null 2>&1 || true
		filter_pii_data ${FULLPATH}
		[ -d /usr/etc/supportinfo-non-pii.d ] && run-parts -a "${FULLPATH}" /usr/etc/supportinfo-non-pii.d >/dev/null 2>&1 || true
		printf "Support information stored in: ${FULLPATH}\n"
	)
}

set_fwupdate_status() {
	local statusfile status
	statusfile=$1
	shift
	status=$*
	echo ${status} > ${statusfile}
}

fw_move() {
	local file rc
	file=$1

	[ "/boot/fwupdate.bin" != "${file}" ] || return 0

	if mountpoint -q /boot >/dev/null 2>&1; then
		mount -o remount,rw /boot || true
	fi

	mv -f "${file}" /boot/fwupdate.bin
	rc=$?

	if mountpoint -q /boot >/dev/null 2>&1; then
		mount -o remount,ro /boot || true
	fi

	return $rc
}

do_fwupdatestatus() {
	local LOCKFILE PID STATUSFILE
	LOCKFILE="/var/run/fwupdate.pid"
	dotlockfile -l -p -r 0 ${LOCKFILE}
	rc=$?
	if [ $rc -ne 0 ]; then
		PID=$(cat ${LOCKFILE})
		STATUSFILE="/var/run/fwupdate.status.${PID}"
		[ ! -f ${STATUSFILE} ] || cat ${STATUSFILE}
		return 0
	fi
	dotlockfile -u ${LOCKFILE}
	echo "none"
	return 1
}

firmware_upgrade_trace() {
	rv="$?"
	local REASON PPID_CMD ERROR_CODE INFO
	local issupport=false
	internal_cleanup
	if [ $rv -ne 0 ]; then
		if [ -x /usr/bin/ubnt_report_handler ]; then
			PPID_CMD=`ps -o cmd= ${PPID} | xargs | base64`
			REASON=`echo -n "${msg}" | base64` # msg from err function
			SUB_REASON=`echo -n "${SUB_REASON}" | base64`
			INFO=
			if [ -z "${FWFILE}" ]; then
				INFO=`echo -n "{}" | base64`
			else
				INFO=`echo -n "{\"file_name\":\"${FWFILE}\",\"file_size\":${FWSIZE},\"fw_version\":\"${FWVERSION}\"}" | base64`
			fi
			if [ -z "${SUB_REASON}" ]; then
				SUB_REASON=`echo -n " " | base64`
			fi
			ERROR_CODE=`echo -n "${rv}" | base64`
			/usr/bin/ubnt_report_handler trace_fwupgrade -h >/dev/null 2>&1 && issupport=true
			if "${issupport}"; then
				/usr/bin/ubnt_report_handler trace_fwupgrade --ppid_cmd "${PPID_CMD}" --reason "${REASON}" --subreason "${SUB_REASON}" --error "${ERROR_CODE}" --info "${INFO}"
			fi
		fi
	fi
}

init_fwupdate_trap() {
	FWFILE=
	FWVERSION=
	FWSIZE=
	SUB_REASON=
	trap firmware_upgrade_trace EXIT
}

is_url() {
	local str=${1}
	echo $str | grep -q -E ^https?://
}

do_fwupdate() {
	local file ver rc LOCKFILE
	if [ -z "${1}" ]; then
		err 2 "No update file!"
	fi

	local keepfile=0
	if [ ! -z "${2}" -a "${2}" = "-k" ]; then
		keepfile=1
	fi

	local LOCKFILE="/var/run/fwupdate.pid"
	dotlockfile -l -p -r 0 ${LOCKFILE}
	rc=$?
	if [ $rc -ne 0 ]; then
		err 1 "cannot aquire lock file (${LOCKFILE}) !"
	fi

	cleanup_init
	cleanup_add_lockfile ${LOCKFILE}

	local PID=$$
	local STATUSFILE="/var/run/fwupdate.status.${PID}"
	echo ${PID}

	if is_url "${1}"; then
		local wget_cmd curl_cmd
		wget_cmd=$(command -v wget 2>/dev/null)
		curl_cmd=$(command -v curl 2>/dev/null)

		[ -n "${wget_cmd}" -o -n "${curl_cmd}" ] || err 6 "Cannot retrieve non-local firmware ${1} (missing wget/curl)!"
		[ -n "${TMPDIR}" ] || TMPDIR=/var/tmp
		mkdir -p "${TMPDIR}" || err 6 "Cannot create directory ${TMPDIR}!"
		rm -f ${TMPDIR}/fwupdate.* >/dev/null 2>&1
		file=$(mktemp -p "${TMPDIR}" fwupdate.XXXXXXXXXX)
		rc=0
		set_fwupdate_status ${STATUSFILE} "downloading"
		if [ -n "${wget_cmd}" ]; then
			${wget_cmd} -O "${file}" -t 5 "${1}"
			rc=$?
		elif [ -n "${curl_cmd}" ]; then
			${curl_cmd} -o "${file}" "${1}"
			rc=$?
		else
			# should never get here..
			rc=69
		fi

		if [ $rc -ne 0 ]; then
			rm -f ${file}
			set_fwupdate_status ${STATUSFILE} "failed"
			err 3 "Failed downloading firmware from ${1}, rc: ${rc}"
		fi
	elif [ -f "${1}" ]; then
		file="${1}"
	else
		err 2 "File not found: ${1}"
	fi

	# Collect trace report afterwards
	init_fwupdate_trap

	FWFILE="${file}"
	FWSIZE=`du -b "${file}" | awk '{print $1}'`

	[ ${keepfile} -eq 1 ] || cleanup_add_file "${file}"

	set_fwupdate_status ${STATUSFILE} "checking"
	if command -v fwinfo >/dev/null 2>&1; then
		ver=$(fwinfo ${file})
		rc=$?
		FWVERSION="$ver"
		if [ $rc -ne 0 ]; then
			set_fwupdate_status ${STATUSFILE} "invalid"
			err 9 "Invalid firmware file ${file}!\n"
		fi
	fi

	echo "Firmware: ${ver}"

	if command -v ubntnas >/dev/null 2>&1; then
		set_fwupdate_status ${STATUSFILE} "moving"
		REASON=$(ubntnas system upgrade ${file} -f --no-reboot)
		rc=$?
		if [ $rc -ne 0 ]; then
			[ ${keepfile} -eq 1 ] || rm -f ${file}
			set_fwupdate_status ${STATUSFILE} "failed"
			err 8 "${REASON}"
		fi
	else
		if [ -x /sbin/pre-fwupdate ]; then
			/sbin/pre-fwupdate
		fi

		if command -v fwupdate >/dev/null 2>&1; then
			SUB_REASON=$(fwupdate -c ${file} 3>&2 2>&1 1>&3)
			rc=$?
			if [ $rc -ne 0 ]; then
				set_fwupdate_status ${STATUSFILE} "invalid"
				err 10 " ${file} (Firmware: ${ver}) doesn't fit the system!\n"
			fi
		fi

		local updater_path="/tmp/fw-updater"
		if command -v fwextract >/dev/null 2>&1; then
			set_fwupdate_status ${STATUSFILE} "updater-extracting"
			SUB_REASON=$(fwextract -t updater -o ${updater_path} ${file} 3>&2 2>&1 1>&3)
			rc=$?
			if [ $rc -ne 0 ]; then
				printf "Failed extracting updater from ${file} to ${updater_path}\n"
			else
				[ -f ${updater_path} ] && chmod 755 ${updater_path}
			fi
		fi

		if [ -x ${updater_path} ]; then
			set_fwupdate_status ${STATUSFILE} "updater-top-running"
			echo "Run updater top..."
			${updater_path} -t top 3>&2 2>&1 1>&3
			rc=$?
			if [ $rc -ne 0 ]; then
				set_fwupdate_status ${STATUSFILE} "failed"
				err 8 "Failed run updater top"
			fi
		fi

		set_fwupdate_status ${STATUSFILE} "moving"
		fw_move "${file}"
		rc=$?
		if [ $rc -ne 0 ]; then
			set_fwupdate_status ${STATUSFILE} "failed"
			err 8 "Failed moving ${file} to /boot/fwupdate.bin"
		fi

		if [ -x ${updater_path} ]; then
			set_fwupdate_status ${STATUSFILE} "updater-bottom-running"
			echo "Run updater bottom..."
			${updater_path} -t bottom -i 3>&2 2>&1 1>&3
		fi

	fi

	set_fwupdate_status ${STATUSFILE} "updating"
	echo "Firmware ready - rebooting to update..."
	dotlockfile -u ${LOCKFILE}
	do_reboot "firmware update"
}

do_pwcheck() {
	exec pwcheck $*
}

do_chpasswd() {
	exec chpasswd $*
}

record_report_info() {
	PPID_CMD=`ps -o cmd= ${PPID} | base64`
	REASON="bWFudWFs" # manual
	if [ "$1" ]; then
		REASON=`echo -n $1 | base64`
	fi
	echo -n "${REASON}" > ${REBOOT_REASON_PATH}
	echo -n "${PPID_CMD}" > ${PPID_CMD_PATH}
}

do_reboot() {
	record_report_info $1
	nohup reboot >/dev/null 2>&1 || reboot -f
}

do_poweroff() {
	record_report_info $1
	nohup poweroff >/dev/null 2>&1 || poweroff -f
}

make_reset_trace_report() {
	if [ -x /usr/bin/ubnt_report_handler ]; then
		PPID_CMD=`ps -o cmd= ${PPID} | base64`
		REASON="bWFudWFs" # manual
		if [ ! -z "$1" ]; then
			REASON=`echo -n $1 | base64`
		fi
		/usr/bin/ubnt_report_handler trace_reset --ppid_cmd "${PPID_CMD}" --reason "${REASON}"
	fi
}

do_reset2defaults() {
	if command -v ubntnas >/dev/null 2>&1; then
		make_reset_trace_report $1
		ubntnas system reset --no-reboot
		if [ "$?" -ne 0 ]; then
			err 1 "fail to reset system to defaults"
		fi
		do_reboot "reset to default"
		return
	fi

	if [ -x /sbin/pre-reset2defaults ]; then
		/sbin/pre-reset2defaults
	fi
	if mountpoint -q /boot >/dev/null 2>&1; then
		mount -o remount,rw /boot
	fi
	touch /boot/reset2defaults
	if [ -x /sbin/post-reset2defaults ]; then
		/sbin/post-reset2defaults
	fi
	journalctl --system --all --no-pager --no-hostname --output=short-iso > /boot/reset2defaults.log
	pstree -hp >> /boot/reset2defaults.log
	sync
	if mountpoint -q /boot >/dev/null 2>&1; then
		mount -o remount,ro /boot
	fi
	if [ -f /boot/reset2defaults ]; then
		make_reset_trace_report $1
		do_reboot "reset to default"
	fi
}

session_cleanup() {
	PHP_SESSIONDIR=/run/php/sessions
	PHP_TMPDIR=/run/php/tmp

	[ -e /etc/default/php ] && . /etc/default/php

	[ -d "${PHP_SESSIONDIR}" ] || return 0

	find "${PHP_SESSIONDIR}" -type f -name 'sess_*' | xargs grep -l 'authed|b:1' | xargs touch
	ls -c -r -1 ${PHP_SESSIONDIR}/ | head -n -5 | xargs rm -f
}

aufs_plink_flush() {
	[ -x /sbin/auplink ] || return 0
	AUFS_MNTS=`mount -t aufs | awk '{print $3}'`
	if [ "${AUFS_MNTS}" != "" ]; then
		for MNT in ${AUFS_MNTS}; do
			/sbin/auplink ${MNT} flush
		done
	fi
}

do_cleanup_hourly() {
	session_cleanup
}

do_cleanup_daily() {
	aufs_plink_flush
}

do_cleanup_weekly() {
	return 0
}

do_cleanup_monthly() {
	return 0
}

do_cleanup_yearly() {
	return 0
}

do_synctime() {
	# let systemd-timesyncd do the job
	/usr/bin/timedatectl set-ntp true
	rc=$?

	if [ $rc -eq 0 ]; then
		echo OK
	else
		echo ERR
	fi

	exit $rc
}

validate_anonid() {
	if ! echo $1 | grep -Eq '[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}'; then
		return 1
	fi
	return 0
}

do_anonid() {
	local anonid_path="/var/run/anonymous_device_id"
	local ubnthal_system="/proc/ubnthal/system.info"
	local anonid=""

	if [ ! -f ${anonid_path} ] || ! validate_anonid $(cat ${anonid_path}); then
		if [ -f ${ubnthal_system} ]; then
			anonid=$(cat /proc/ubnthal/system.info | awk -F= '{if ($1=="device.anonid") print $2}')
			if validate_anonid ${anonid}; then
				echo ${anonid} > ${anonid_path}
			else
				/sbin/ubnt-tools uuid > ${anonid_path}
			fi
		else
			/sbin/ubnt-tools uuid > ${anonid_path}
		fi
	fi
	cat ${anonid_path}
}

do_storage() {
	local action=${1}

	case "${action}" in
		reset)
			local arg=${2}
			if [ "${arg}" = "all" ]; then
				if command -v ustorage >/dev/null 2>&1; then
					ustorage space nuke
				elif command -v ubntstorage >/dev/null 2>&1; then
					ubntstorage space nuke nukeit=true
				else
					err 3 "storage endpoint is missing"
				fi
				if [ "$?" -ne 0 ]; then
					err 1 "fail to reset all storage"
				fi
			fi
			;;
		*)
			err 2 "storage action [${action}] is not support"
			;;
	esac
}

do_cputemp() {
	local temp_file="/sys/class/thermal/thermal_zone0/temp"
	if [ -r "/etc/default/cpu_temp" ]; then
		temp_file="/etc/default/cpu_temp"
	fi

	if [ ! -f "$temp_file" ]; then
		echo 0
	fi

	local temp=$(cat $temp_file)
	if [ $temp -gt 1000 ] ; then
		temp=$((temp/1000))
	fi
	echo $temp
}

do_sysusermerge() {
	local passwd_path="$1/etc/passwd"
	local group_path="$1/etc/group"
	local old_groups="$(awk -F: '{print $1}' $group_path)"
	local old_users="$(awk -F: '{print $1}' $passwd_path)"
	# migrate group
	for old_group in $old_groups; do
		if ! getent group $old_group 2>&1 > /dev/null; then
			echo "$old_group not exist"
			groupadd --system $old_group
		fi
	done
	# migrate user
	for old_user in $old_users; do
		if ! getent passwd $old_user 2>&1 > /dev/null; then
			echo "$old_user need to merge"
			cat $passwd_path | awk -v old_user=$old_user -F: '$1 == old_user {print $0}' | while IFS=: read -r name password uid gid gecos home shell; do
				old_group="$(cat $group_path | awk -v gid=$gid -F: '$3 == gid {print $1}')"
				useradd --gid $old_group --no-create-home --home-dir "$home" --system --shell "$shell" -c "$gecos" $name
			done
		fi
	done
}

do_sysuser_remap() {
    local passwd_path="$1/etc/passwd"
    local group_path="$1/etc/group"
    local ro_passwd_info="$(awk -F: '{print $1 ":" $3}' ${passwd_path})"
    local ro_group_info="$(awk -F: '{print $1 ":" $3}' ${group_path})"

    local uid_tmp=1001
    local gid_tmp=1001

    local check_files="/etc /data /var/log /ssd1 /persistent /home /srv"

    # remap group
    for ro_info_ in ${ro_group_info}; do
        ro_group=${ro_info_%%:*}
        ro_gid=${ro_info_##*:}

        rw_gid=$(getent group ${ro_group})
        rw_gid=${rw_gid%:*}
        rw_gid=${rw_gid##*:}

        echo "Check ${ro_group} GID..."
        if [ "${rw_gid}" -ne "${ro_gid}" ]; then
            echo "Change GID of ${ro_group} from ${rw_gid} to ${ro_gid}"
            echo "Check if GID ${ro_gid} exit"

            dup_group=$(getent group ${ro_gid})
            dup_group=${dup_group%%:*}

            if [ "${dup_group}" ]; then
                #Prevent undefined gid stuck
                while [ "$(getent group ${gid_tmp})" ]; do
                    echo "gid_tmp ${gid_tmp} exist, gid_tmp++"
                    gid_tmp=$((gid_tmp+1))
                done

                echo "Group ${dup_group} exist"
                echo "move duplicate group ${dup_group} gid from ${ro_gid} to ${gid_tmp}"
                groupmod -g ${gid_tmp} ${dup_group}
                find ${check_files} -group ${ro_gid} -exec chgrp -h ${dup_group} {} \;
                gid_tmp=$((gid_tmp+1))
            fi

            if ! `groupmod -g ${ro_gid} ${ro_group}` > /dev/null 2>&1; then
                echo "Change GID Failed"
            else
                echo "Chgrp file... gid= ${rw_gid} -> ${ro_gid}"
                find ${check_files} -group ${rw_gid} -exec chgrp -h ${ro_group} {} \;
            fi
        fi
    done


    # remap user
    for ro_info_ in ${ro_passwd_info}; do
        ro_user=${ro_info_%%:*}
        ro_uid=${ro_info_##*:}

        rw_uid=$(id -u ${ro_user})

        echo "Check ${ro_user} UID..."
        if [ "${rw_uid}" -ne "${ro_uid}" ]; then
            #Prevent undefined uid stuck
            while [ "$(getent passwd ${uid_tmp})" ]; do
                    echo "uid_tmp ${uid_tmp} exist, uid_tmp++"
                    uid_tmp=$((uid_tmp+1))
            done

            echo "Change UID of ${ro_user} from ${rw_uid} to ${ro_uid}"
            echo "Check if UID ${ro_uid} exist"

            dup_user=$(id -nu ${ro_uid})

            if [ "${dup_user}" ]; then
                echo "User ${dup_user} Exist"
                echo "move duplicate user ${dup_user} uid from ${ro_uid} to ${uid_tmp}"
                usermod -u ${uid_tmp} ${dup_user}
                find ${check_files} -user ${ro_uid} -exec chown -h ${dup_user} {} \;
                uid_tmp=$((uid_tmp+1))
            fi

            if ! `usermod -u ${ro_uid} ${ro_user}` > /dev/null 2>&1; then
                echo "Change UID Failed"
            else
                echo "Chown file... uid= ${rw_uid} -> ${ro_uid}"
                find ${check_files} -user ${rw_uid} -exec chown -h ${ro_user} {} \;
            fi
        fi
    done

}

do_cpuload() {
	local load_file="/var/run/cpuload"
	if [ -f "$load_file" ]; then
		cat $load_file
	else
		last_cpu=$(cat /proc/stat)
		last_use=$(echo $last_cpu | awk -F' ' '$1 == "cpu" {print $2 + $3 + $4 + $7 + $8 + $9}')
		last_total=$(echo $last_cpu | awk -F' ' '$1 == "cpu" {print $2 + $3 + $4 + $5 + $6 + $7 + $8 + $9}')
		sleep 1
		current_cpu=$(cat /proc/stat)
		current_use=$(echo $current_cpu | awk -F' ' '$1 == "cpu" {print $2 + $3 + $4 + $7 + $8 + $9}')
		current_total=$(echo $current_cpu | awk -F' ' '$1 == "cpu" {print $2 + $3 + $4 + $5 + $6 + $7 + $8 + $9}')
		printf %.1f "$(( 1000 * ($current_use - $last_use) / ($current_total - $last_total) ))e-1"
	fi
}

validate_passwd() {
	echo "$1" | grep -Eq '\$y\$[./A-Za-z0-9]+\$[./A-Za-z0-9]{,86}\$[./A-Za-z0-9]{43}|\$gy\$[./A-Za-z0-9]+\$[./A-Za-z0-9]{,86}\$[./A-Za-z0-9]{43}|\$7\$[./A-Za-z0-9]{11,97}\$[./A-Za-z0-9]{43}|\$2[abxy]\$[0-9]{2}\$[./A-Za-z0-9]{53}|\$6\$[./0-9A-Za-z]{,16}\$[./0-9A-Za-z]{86}|\$5\$[./0-9A-Za-z]{,16}\$[./0-9A-Za-z]{43}|\$sha1\$[1-9][0-9]+\$[./0-9A-Za-z]{1,64}\$[./0-9A-Za-z]{8,64}[./0-9A-Za-z]{32}|\$md5\$[./0-9A-Za-z]{8}\${1,2}[./0-9A-Za-z]{22}|\$1\$[^$:\n]{1,8}\$[./0-9A-Za-z]{22}'
}

do_sshpasswd() {
	case $1 in
		get)
			awk -F: '{if ($1 == "root") print $2}' /etc/shadow
			;;
		set)
			if validate_passwd "$2"; then
				echo "root:$2" | chpasswd -e
			else
				err 2 "invalid password format"
			fi
			;;
		*)
			err 1 "unknown action [$1] for ssh_passwd"
			;;
	esac
}

[ $# -lt 1 ] && usage

CMD=$1

trap 'internal_cleanup' EXIT HUP INT

case ${CMD} in
	timezone|hostname)
		[ $# -lt 2 ] && usage
		do_cmd="change_${CMD}"
		eval ${do_cmd} $2
	;;
	network)
		[ $# -lt 2 ] && usage
		if [ $# -eq 3 ]; then
			eval change_network $2 $3
		else
			return 1
		fi
	;;
	network-speed-init)
		[ $# -lt 1 ] && usage
		eval init_network_speed
	;;
	network-speed)
		[ $# -lt 2 ] && usage
		if [ $# -eq 2 ]; then
			eval show_network_speed $2
		else
			eval change_network_speed $2 $3
		fi
	;;
	adminname)
		[ $# -lt 2 ] && usage
		eval change_admin name $2
	;;
	adminemail)
		[ $# -lt 2 ] && usage
		eval change_admin email $2
	;;
	pwcheck|chpasswd|resetbutton|fwupdate|ssh|sshd|sshd-port|sshd-passwdauth| \
	sshd-authkeys|support|anonid|storage|sysusermerge|sshpasswd|sysuser_remap)
		cmdname=$(echo $CMD | tr -d '-')
		do_cmd="do_${cmdname}"
		shift
		eval ${do_cmd} $@
	;;
	reboot|poweroff|reset2defaults)
		do_cmd="do_${CMD}"
		shift
		eval ${do_cmd} \"$1\"
	;;
	fwupdatestatus|synctime|cputemp|cpuload)
		do_cmd="do_${CMD}"
		eval ${do_cmd}
	;;
	cleanup)
		if [ $# -ge 2 ] ; then
			case $2 in
				hourly|daily|weekly|monthly|yearly)
				do_cmd="do_cleanup_$2"
				eval ${do_cmd}
				;;
			*)
				usage
				;;
			esac
		else
			do_cmd="do_cleanup_hourly"
			eval ${do_cmd}
		fi
	;;
	*)
		usage
	;;
esac
